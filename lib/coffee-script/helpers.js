// Generated by CoffeeScript 1.3.3
var CS, beingDeclared, cleanMarkers, concat, concatMap, difference, envEnrichments, envEnrichments_, foldl, humanReadable, map, nub, numberLines, usedAsExpression, usedAsExpression_, _ref,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ref = require('./functional-helpers'), concat = _ref.concat, concatMap = _ref.concatMap, difference = _ref.difference, foldl = _ref.foldl, map = _ref.map, nub = _ref.nub;

CS = require('./nodes');

this.numberLines = numberLines = function(input, startLine) {
  var currLine, i, line, lines, numbered, pad, padSize;
  if (startLine == null) {
    startLine = 1;
  }
  lines = input.split('\n');
  padSize = ((lines.length + startLine - 1).toString(10)).length;
  numbered = (function() {
    var _i, _len, _results;
    _results = [];
    for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
      line = lines[i];
      currLine = "" + (i + startLine);
      pad = ((Array(padSize + 1)).join('0')).slice(currLine.length);
      _results.push("" + pad + currLine + " : " + lines[i]);
    }
    return _results;
  })();
  return numbered.join('\n');
};

cleanMarkers = function(str) {
  return str.replace(/[\uEFEF\uEFFE\uEFFF]/g, '');
};

this.humanReadable = humanReadable = function(str) {
  return (((str.replace(/\uEFEF/g, '(INDENT)')).replace(/\uEFFE\uEFFF/g, '(DEDENT)')).replace(/\uEFFE/g, '(TERMINATOR)')).replace(/\uEFFF/g, '(DEDENT)');
};

this.formatParserError = function(input, e) {
  var currentLineOffset, found, lines, message, numLinesOfContext, numberedLines, padSize, postLines, preLines, startLine;
  numLinesOfContext = 3;
  if (e.found != null) {
    lines = input.split('\n');
    currentLineOffset = e.line - 1;
    startLine = currentLineOffset - numLinesOfContext;
    if (startLine < 0) {
      startLine = 0;
    }
    preLines = lines.slice(startLine, currentLineOffset + 1 || 9e9);
    postLines = lines.slice(currentLineOffset + 1, (currentLineOffset + numLinesOfContext) + 1 || 9e9);
    numberedLines = (numberLines(cleanMarkers(__slice.call(preLines).concat(__slice.call(postLines)).join('\n')), startLine + 1)).split('\n');
    preLines = numberedLines.slice(0, preLines.length);
    postLines = numberedLines.slice(preLines.length);
    e.column = (cleanMarkers(("" + lines[currentLineOffset] + "\n").slice(0, e.column))).length;
  }
  found = e.found != null ? "'" + ((((JSON.stringify(humanReadable(e.found))).replace(/^"|"$/g, '')).replace(/'/g, '\\\'')).replace(/\\"/g, '"')) + "'" : 'end of input';
  message = "Syntax error on line " + e.line + ", column " + e.column + ": unexpected " + found;
  if (e.found != null) {
    padSize = ((currentLineOffset + 1 + postLines.length).toString(10)).length;
    message = [message].concat(__slice.call(preLines), ["" + ((Array(padSize + 1)).join('^')) + " :~" + ((Array(e.column)).join('~')) + "^"], __slice.call(postLines)).join('\n');
  }
  return message;
};

this.beingDeclared = beingDeclared = function(assignment) {
  switch (false) {
    case !!(assignment != null):
      return [];
    case !assignment["instanceof"](CS.Identifiers):
      return [assignment.data];
    case !assignment["instanceof"](CS.Rest):
      return beingDeclared(assignment.expression);
    case !assignment["instanceof"](CS.MemberAccessOps):
      return [];
    case !assignment["instanceof"](CS.DefaultParam):
      return beingDeclared(assignment.param);
    case !assignment["instanceof"](CS.ArrayInitialiser):
      return concatMap(assignment.members, beingDeclared);
    case !assignment["instanceof"](CS.ObjectInitialiser):
      return concatMap(assignment.vals(), beingDeclared);
    default:
      throw new Error("beingDeclared: Non-exhaustive patterns in case: " + assignment.className);
  }
};

this.declarationsFor = function(node, inScope) {
  var vars;
  vars = envEnrichments(node, inScope);
  return foldl((new CS.Undefined).g(), vars, function(expr, v) {
    return (new CS.AssignOp((new CS.Identifier(v)).g(), expr)).g();
  });
};

usedAsExpression_ = function(ancestors) {
  var grandparent, parent;
  parent = ancestors[0];
  grandparent = ancestors[1];
  switch (false) {
    case !!(parent != null):
      return true;
    case !parent["instanceof"](CS.Program, CS.Class):
      return false;
    case !parent["instanceof"](CS.SeqOp):
      return this === parent.right && usedAsExpression(parent, ancestors.slice(1));
    case !((parent["instanceof"](CS.Block)) && (parent.statements.indexOf(this)) !== parent.statements.length - 1):
      return false;
    case !((parent["instanceof"](CS.Functions)) && parent.body === this && (grandparent != null ? grandparent["instanceof"](CS.Constructor) : void 0)):
      return false;
    default:
      return true;
  }
};

this.usedAsExpression = usedAsExpression = function(node, ancestors) {
  return usedAsExpression_.call(node, ancestors);
};

envEnrichments_ = function(inScope) {
  var possibilities;
  if (inScope == null) {
    inScope = [];
  }
  possibilities = (function() {
    var _this = this;
    switch (false) {
      case !this["instanceof"](CS.AssignOp):
        return nub(beingDeclared(this.assignee));
      case !this["instanceof"](CS.Class):
        return nub(concat([beingDeclared(this.nameAssignee), envEnrichments(this.parent), typeof name !== "undefined" && name !== null ? [name] : []]));
      case !this["instanceof"](CS.ForIn, CS.ForOf):
        return nub(concat([
          concatMap(this.childNodes, function(child) {
            if (__indexOf.call(_this.listMembers, child) >= 0) {
              return concatMap(_this[child], function(m) {
                return envEnrichments(m, inScope);
              });
            } else {
              return envEnrichments(_this[child], inScope);
            }
          }), beingDeclared(this.keyAssignee), beingDeclared(this.valAssignee)
        ]));
      default:
        return nub(concatMap(this.childNodes, function(child) {
          if (__indexOf.call(_this.listMembers, child) >= 0) {
            return concatMap(_this[child], function(m) {
              return envEnrichments(m, inScope);
            });
          } else {
            return envEnrichments(_this[child], inScope);
          }
        }));
    }
  }).call(this);
  return difference(possibilities, inScope);
};

this.envEnrichments = envEnrichments = function() {
  var args, node;
  node = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  if (node != null) {
    return envEnrichments_.apply(node, args);
  } else {
    return [];
  }
};
