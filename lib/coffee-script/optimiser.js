// Generated by CoffeeScript 1.3.3
var CS, all, any, beingDeclared, concat, concatMap, declarationsFor, difference, envEnrichments, exports, foldl, foldl1, isFalsey, isTruthy, makeDispatcher, mayHaveSideEffects, union, usedAsExpression, _ref, _ref1, _ref2,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ref = require('./functional-helpers'), all = _ref.all, any = _ref.any, concat = _ref.concat, concatMap = _ref.concatMap, difference = _ref.difference, foldl = _ref.foldl, foldl1 = _ref.foldl1, union = _ref.union;

_ref1 = require('./helpers'), beingDeclared = _ref1.beingDeclared, declarationsFor = _ref1.declarationsFor, usedAsExpression = _ref1.usedAsExpression, envEnrichments = _ref1.envEnrichments;

CS = require('./nodes');

exports = (_ref2 = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref2 : this;

makeDispatcher = function(defaultValue, handlers, defaultHandler) {
  var ctor, ctors, handler, handlers_, _i, _j, _len, _len1, _ref3;
  if (defaultHandler == null) {
    defaultHandler = (function() {});
  }
  handlers_ = {};
  for (_i = 0, _len = handlers.length; _i < _len; _i++) {
    _ref3 = handlers[_i], ctors = _ref3[0], handler = _ref3[1];
    for (_j = 0, _len1 = ctors.length; _j < _len1; _j++) {
      ctor = ctors[_j];
      handlers_[ctor.prototype.className] = handler;
    }
  }
  return function() {
    var args, node;
    node = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (node == null) {
      return defaultValue;
    }
    handler = Object.prototype.hasOwnProperty.call(handlers_, node.className) ? handlers_[node.className] : defaultHandler;
    return handler.apply(node, args);
  };
};

isTruthy = makeDispatcher(false, [
  [
    [CS.ArrayInitialiser, CS.Class, CS.DeleteOp, CS.ForIn, CS.ForOf, CS.Function, CS.BoundFunction, CS.HeregExp, CS.ObjectInitialiser, CS.Range, CS.RegExp, CS.Slice, CS.TypeofOp, CS.While], function() {
      return true;
    }
  ], [
    [CS.AssignOp], function() {
      return isTruthy(this.expression);
    }
  ], [
    [CS.Block], function() {
      if (this.statements.length === 0) {
        return false;
      } else {
        return isTruthy(this.statements[this.statements.length - 1]);
      }
    }
  ], [
    [CS.Bool, CS.Float, CS.Int, CS.String], function() {
      return !!this.data;
    }
  ], [
    [CS.Conditional], function() {
      return (isTruthy(this.condition)) && (isTruthy(this.consequent)) || (isFalsey(this.condition)) && isTruthy(this.alternate);
    }
  ], [
    [CS.LogicalAndOp], function() {
      return (isTruthy(this.left)) && isTruthy(this.right);
    }
  ], [
    [CS.LogicalNotOp], function() {
      return isFalsey(this.expression);
    }
  ], [
    [CS.LogicalOrOp], function() {
      return (isTruthy(this.left)) || isTruthy(this.right);
    }
  ], [
    [CS.Program], function() {
      return isTruthy(this.body);
    }
  ], [
    [CS.SeqOp], function() {
      return isTruthy(this.right);
    }
  ], [
    [CS.Switch], function() {
      return (all(this.cases, isTruthy)) && (this.alternate != null ? isTruthy(this.alternate) : true);
    }
  ], [
    [CS.SwitchCase], function() {
      return isTruthy(this.consequent);
    }
  ], [
    [CS.UnaryExistsOp], function() {
      return (isTruthy(this.expression)) || this.expression["instanceof"](CS.Int, CS.Float, CS.String, CS.UnaryPlusOp, CS.UnaryNegateOp, CS.LogicalNotOp);
    }
  ]
], function() {
  return false;
});

isFalsey = makeDispatcher(false, [
  [
    [CS.Null, CS.Undefined], function() {
      return true;
    }
  ], [
    [CS.AssignOp], function() {
      return isFalsey(this.expression);
    }
  ], [
    [CS.Block], function() {
      if (this.statements.length === 0) {
        return true;
      } else {
        return isFalsey(this.statements[this.statements.length - 1]);
      }
    }
  ], [
    [CS.Bool, CS.Float, CS.Int, CS.String], function() {
      return !this.data;
    }
  ], [
    [CS.Conditional], function() {
      return (isTruthy(this.condition)) && (isFalsey(this.consequent)) || (isFalsey(this.condition)) && isFalsey(this.alternate);
    }
  ], [
    [CS.LogicalAndOp], function() {
      return (isFalsey(this.left)) || isFalsey(this.right);
    }
  ], [
    [CS.LogicalNotOp], function() {
      return isTruthy(this.expression);
    }
  ], [
    [CS.LogicalOrOp], function() {
      return (isFalsey(this.left)) && isFalsey(this.right);
    }
  ], [
    [CS.Program], function() {
      return isFalsey(this.body);
    }
  ], [
    [CS.SeqOp], function() {
      return isFalsey(this.right);
    }
  ], [
    [CS.Switch], function() {
      return (all(this.cases, isFalsey)) && (this.alternate != null ? isFalsey(this.alternate) : true);
    }
  ], [
    [CS.SwitchCase], function() {
      return isFalsey(this.block);
    }
  ], [
    [CS.UnaryExistsOp], function() {
      return this.expression["instanceof"](CS.Null, CS.Undefined);
    }
  ]
], function() {
  return false;
});

mayHaveSideEffects = makeDispatcher(false, [
  [
    [CS.Function, CS.BoundFunction, CS.Null, CS.RegExp, CS.This, CS.Undefined], function() {
      return false;
    }
  ], [
    [CS.Break, CS.Continue, CS.DeleteOp, CS.NewOp, CS.Return, CS.Super, CS.PreDecrementOp, CS.PreIncrementOp, CS.PostDecrementOp, CS.PostIncrementOp, CS.ClassProtoAssignOp, CS.Constructor], function() {
      return true;
    }
  ], [
    [CS.Class], function(inScope) {
      return (mayHaveSideEffects(this.parent, inScope)) || (this.nameAssignee != null) && (this.name || (beingDeclared(this.nameAssignee)).length > 0);
    }
  ], [
    [CS.Conditional], function(inScope) {
      return (mayHaveSideEffects(this.condition, inScope)) || (!isFalsey(this.condition)) && (mayHaveSideEffects(this.consequent, inScope)) || (!isTruthy(this.condition)) && mayHaveSideEffects(this.alternate, inScope);
    }
  ], [
    [CS.DoOp], function(inScope) {
      var args, newScope, p;
      if (!this.expression["instanceof"](CS.Functions)) {
        return true;
      }
      newScope = difference(inScope, concatMap(this.expression.parameters, beingDeclared));
      args = (function() {
        var _i, _len, _ref3, _results;
        _ref3 = this.expression.parameters;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          p = _ref3[_i];
          if (p["instanceof"](CS.AssignOp)) {
            _results.push(p.expression);
          } else {
            _results.push(p);
          }
        }
        return _results;
      }).call(this);
      if (any(args, function(a) {
        return mayHaveSideEffects(a, newScope);
      })) {
        return true;
      }
      return mayHaveSideEffects(this.expression.body, newScope);
    }
  ], [
    [CS.ExistsOp], function(inScope) {
      if (mayHaveSideEffects(this.left, inScope)) {
        return true;
      }
      if (this.left["instanceof"](CS.Undefined, CS.Null)) {
        return false;
      }
      return mayHaveSideEffects(this.right, inScope);
    }
  ], [
    [CS.FunctionApplication], function(inScope) {
      var newScope;
      if (!this["function"]["instanceof"](CS.Function, CS.BoundFunction)) {
        return true;
      }
      newScope = difference(inScope, concatMap(this["function"].parameters, beingDeclared));
      if (any(this["arguments"], function(a) {
        return mayHaveSideEffects(a, newScope);
      })) {
        return true;
      }
      return mayHaveSideEffects(this["function"].body, newScope);
    }
  ], [
    [CS.LogicalAndOp], function(inScope) {
      if (mayHaveSideEffects(this.left, inScope)) {
        return true;
      }
      if (isFalsey(this.left)) {
        return false;
      }
      return mayHaveSideEffects(this.right, inScope);
    }
  ], [
    [CS.LogicalOrOp], function(inScope) {
      if (mayHaveSideEffects(this.left, inScope)) {
        return true;
      }
      if (isTruthy(this.left)) {
        return false;
      }
      return mayHaveSideEffects(this.right, inScope);
    }
  ], [
    [CS.While], function(inScope) {
      return (mayHaveSideEffects(this.condition, inScope)) || (!isFalsey(this.condition)) && mayHaveSideEffects(this.body, inScope);
    }
  ], [
    [CS.AssignOp, CS.ClassProtoAssignOp, CS.CompoundAssignOp, CS.ExistsAssignOp], function(inScope) {
      return true;
    }
  ], [
    [CS.Bool, CS.Float, CS.Identifier, CS.Int, CS.JavaScript, CS.String], function() {
      return false;
    }
  ]
], function(inScope) {
  var _this = this;
  return any(this.childNodes, function(child) {
    if (__indexOf.call(_this.listMembers, child) >= 0) {
      return any(_this[child], function(m) {
        return mayHaveSideEffects(m, inScope);
      });
    } else {
      return mayHaveSideEffects(_this[child], inScope);
    }
  });
});

exports.Optimiser = (function() {
  var defaultRules,
    _this = this;

  Optimiser.optimise = function() {
    var _ref3;
    return (_ref3 = new Optimiser).optimise.apply(_ref3, arguments);
  };

  Optimiser.isTruthy = isTruthy;

  Optimiser.isFalsey = isFalsey;

  Optimiser.mayHaveSideEffects = mayHaveSideEffects;

  defaultRules = [
    [
      CS.Program, function() {
        if ((this.body != null) && mayHaveSideEffects(this.body, [])) {
          return this;
        } else {
          return new CS.Program(null);
        }
      }
    ], [
      CS.Block, function(inScope, ancestors) {
        return foldl((new CS.Undefined).g(), this.statements, function(expr, s) {
          return new CS.SeqOp(expr, s);
        });
      }
    ], [
      CS.SeqOp, function(inScope, ancestors) {
        var canDropLast, ref, _ref3, _ref4;
        canDropLast = !usedAsExpression(this, ancestors);
        if (mayHaveSideEffects(this.left, inScope)) {
          if (mayHaveSideEffects(this.right, inScope)) {
            return this;
          } else if (!canDropLast) {
            return this;
          } else if (this.right["instanceof"](CS.Undefined)) {
            return this.left;
          } else {
            return new CS.SeqOp(this.left, declarationsFor(this.right, inScope));
          }
        } else if ((this.right["instanceof"](CS.Identifier)) && this.right.data === 'eval' && (((_ref3 = ancestors[0]) != null ? _ref3["instanceof"](CS.FunctionApplication) : void 0) && ancestors[0]["function"] === this || ((_ref4 = ancestors[0]) != null ? _ref4["instanceof"](CS.DoOp) : void 0) && ancestors[0].expression === this)) {
          if ((this.left["instanceof"](CS.Int)) && this.left.data === 0) {
            return this;
          }
          ref = new CS.SeqOp((new CS.Int(0)).g(), this.right);
          if ((envEnrichments(this.left, inScope)).length === 0) {
            return ref;
          } else {
            return new CS.SeqOp(declarationsFor(this.left), ref);
          }
        } else {
          if (mayHaveSideEffects(this.right, inScope)) {
            if (this.left["instanceof"](CS.Undefined)) {
              return this.right;
            } else {
              return new CS.SeqOp(declarationsFor(this.left, inScope), this.right);
            }
          } else if (canDropLast) {
            return declarationsFor(this, inScope);
          } else {
            return this.right;
          }
        }
      }
    ], [
      CS.AssignOp, function() {
        if (!this.expression["instanceof"](CS.SeqOp)) {
          return this;
        }
        return new CS.SeqOp(this.expression.left, new CS.AssignOp(this.assignee, this.expression.right));
      }
    ], [
      CS.While, function(inScope) {
        if (isFalsey(this.condition)) {
          return new CS.Block([mayHaveSideEffects(this.condition, inScope) ? new CS.SeqOp(this.condition, declarationsFor(this.body)) : this.body != null ? declarationsFor(this.body, inScope) : new CS.Undefined, new CS.ArrayInitialiser([])]);
        } else if (isTruthy(this.condition)) {
          if (mayHaveSideEffects(this.condition, inScope)) {
            return this;
          } else if (this.body != null) {
            if (this instanceof CS.Loop) {
              return this;
            } else {
              return (new CS.Loop(this.body)).g();
            }
          } else {
            return new CS.ArrayInitialiser([]);
          }
        } else {
          return this;
        }
      }
    ], [
      CS.Conditional, function(inScope) {
        var block, decls;
        if (isFalsey(this.condition)) {
          block = this.alternate;
        } else if (isTruthy(this.condition)) {
          block = this.consequent;
        } else {
          return this;
        }
        decls = declarationsFor(block, inScope);
        block = block != null ? new CS.SeqOp(decls, block) : decls;
        if (mayHaveSideEffects(this.condition, inScope)) {
          block = new CS.SeqOp(this.condition, block);
        }
        return block;
      }
    ], [
      CS.ForIn, function(inScope, ancestors) {
        if (!((this.target["instanceof"](CS.ArrayInitialiser)) && this.target.members.length === 0)) {
          return this;
        }
        return new CS.SeqOp(declarationsFor(this, inScope), (new CS.ArrayInitialiser([])).g());
      }
    ], [
      CS.ForOf, function(inScope, ancestors) {
        if (!(this.isOwn && (this.target["instanceof"](CS.ObjectInitialiser)) && this.target.members.length === 0)) {
          return this;
        }
        return new CS.SeqOp(declarationsFor(this, inScope), (new CS.ArrayInitialiser([])).g());
      }
    ], [
      CS.ForIn, CS.ForOf, function(inScope, ancestors) {
        if (!isFalsey(this.filter)) {
          return this;
        }
        return new CS.SeqOp(declarationsFor(this, inScope), (new CS.ArrayInitialiser([])).g());
      }
    ], [
      CS.ForIn, function() {
        if (!isTruthy(this.filter)) {
          return this;
        }
        return new CS.ForIn(this.valAssignee, this.keyAssignee, this.target, this.step, null, this.body);
      }
    ], [
      CS.ForOf, function() {
        if (!isTruthy(this.filter)) {
          return this;
        }
        return new CS.ForOf(this.isOwn, this.keyAssignee, this.valAssignee, this.target, null, this.body);
      }
    ], [
      CS.ArrayInitialiser, function(inScope, ancestors) {
        if (usedAsExpression(this, ancestors)) {
          return this;
        } else {
          return foldl((new CS.Undefined).g(), this.members, function(expr, m) {
            return new CS.SeqOp(expr, m);
          });
        }
      }
    ], [
      CS.ExistsOp, function() {
        if (this.left["instanceof"](CS.Null, CS.Undefined)) {
          return this.right;
        } else {
          return this;
        }
      }
    ], [
      CS.UnaryExistsOp, function() {
        if (this.expression["instanceof"](CS.Null, CS.Undefined)) {
          return (new CS.Bool(false)).g();
        } else {
          return this;
        }
      }
    ], [
      CS.LogicalNotOp, function(inScope) {
        switch (false) {
          case !this.expression["instanceof"](CS.Int, CS.Float, CS.String, CS.Bool):
            return (new Bool(!this.expression.data)).g();
          case !this.expression["instanceof"](CS.Functions):
            return (new CS.Bool(false)).g();
          case !this.expression["instanceof"](CS.Null, CS.Undefined):
            return (new CS.Bool(true)).g();
          case !this.expression["instanceof"](CS.ArrayInitialiser, CS.ObjectInitialiser):
            if (mayHaveSideEffects(this.expression, inScope)) {
              return this;
            } else {
              return new CS.SeqOp(declarationsFor(this.expression, inScope), (new CS.Bool(false)).g());
            }
            break;
          case !this.expression["instanceof"](CS.LogicalNotOp):
            if (this.expression.expression["instanceof"](CS.LogicalNotOp)) {
              return this.expression.expression;
            } else {
              return this;
            }
            break;
          default:
            return this;
        }
      }
    ], [
      CS.TypeofOp, function() {
        switch (false) {
          case !this.expression["instanceof"](CS.Int, CS.Float, CS.UnaryNegateOp, CS.UnaryPlusOp):
            return (new String('number')).g();
          case !this.expression["instanceof"](CS.String):
            return (new CS.String('string')).g();
          case !this.expression["instanceof"](CS.Functions):
            return (new CS.String('function')).g();
          case !this.expression["instanceof"](CS.Undefined):
            return (new CS.String('undefined')).g();
          default:
            return this;
        }
      }
    ], [
      CS.SeqOp, function(_, ancestors) {
        var _ref3;
        if (!(((_ref3 = ancestors[0]) != null ? _ref3["instanceof"](CS.Functions) : void 0) && ancestors[0].body === this)) {
          return this;
        }
        if ((this.right["instanceof"](CS.Return)) && (this.right.expression != null)) {
          return new CS.SeqOp(this.left, this.right.expression);
        } else if (this.right["instanceof"](CS.Undefined)) {
          return new CS.SeqOp(this.left, new CS.Return);
        } else {
          return this;
        }
      }
    ], [
      CS.Function, CS.BoundFunction, function() {
        if (!((this.block != null) && ((this.block["instanceof"](CS.Undefined)) || (this.block["instanceof"](CS.Return)) && !(this.block.expression != null)))) {
          return this;
        }
        return new this.constructor(this.parameters, null);
      }
    ], [
      CS.Return, function() {
        var _ref3;
        if ((_ref3 = this.expression) != null ? _ref3["instanceof"](CS.Undefined) : void 0) {
          return new CS.Return;
        } else {
          return this;
        }
      }
    ], [
      CS.Slice, function() {
        var _ref3, _ref4;
        if (((_ref3 = this.left) != null ? _ref3["instanceof"](CS.Int, CS.String) : void 0) && +this.left.data === 0) {
          return new CS.Slice(this.expression, this.isInclusive, null, this.right);
        } else if (this.isInclusive && ((_ref4 = this.right) != null ? _ref4["instanceof"](CS.UnaryNegateOp) : void 0) && (this.right.expression["instanceof"](CS.Int)) && this.right.expression.data === 1) {
          return new CS.Slice(this.expression, true, this.left, null);
        } else {
          return this;
        }
      }
    ]
  ];

  function Optimiser() {
    var ctor, ctors, handler, _i, _j, _k, _len, _len1, _ref3;
    this.rules = {};
    for (_i = 0, _len = defaultRules.length; _i < _len; _i++) {
      _ref3 = defaultRules[_i], ctors = 2 <= _ref3.length ? __slice.call(_ref3, 0, _j = _ref3.length - 1) : (_j = 0, []), handler = _ref3[_j++];
      for (_k = 0, _len1 = ctors.length; _k < _len1; _k++) {
        ctor = ctors[_k];
        this.addRule(ctor.prototype.className, handler);
      }
    }
  }

  Optimiser.prototype.addRule = function(ctor, handler) {
    var _base, _ref3;
    ((_ref3 = (_base = this.rules)[ctor]) != null ? _ref3 : _base[ctor] = []).push(handler);
    return this;
  };

  Optimiser.prototype.optimise = (function() {
    var walk;
    walk = function(fn, inScope, ancestry) {
      var child, childName, member, _i, _len, _ref3;
      if (inScope == null) {
        inScope = [];
      }
      if (ancestry == null) {
        ancestry = [];
      }
      if (!(typeof this !== "undefined" && this !== null) || this === global) {
        throw new Error('Optimiser rules must produce a node. `null` is not a node.');
      }
      if (__indexOf.call(ancestry, this) >= 0) {
        return this;
      }
      ancestry.unshift(this);
      _ref3 = this.childNodes;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        childName = _ref3[_i];
        if (this[childName] != null) {
          this[childName] = (function() {
            var _j, _len1, _ref4, _results;
            if (__indexOf.call(this.listMembers, childName) >= 0) {
              _ref4 = this[childName];
              _results = [];
              for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
                member = _ref4[_j];
                while (member !== walk.call((member = fn.call(member, inScope, ancestry)), fn, inScope, ancestry)) {}
                inScope = union(inScope, envEnrichments(member, inScope));
                _results.push(member);
              }
              return _results;
            } else {
              child = this[childName];
              while (child !== walk.call((child = fn.call(child, inScope, ancestry)), fn, inScope, ancestry)) {}
              inScope = union(inScope, envEnrichments(child, inScope));
              return child;
            }
          }).call(this);
        }
      }
      ancestry.shift();
      return fn.call(this, inScope, ancestry);
    };
    return function(ast) {
      var rules;
      rules = this.rules;
      return walk.call(ast, function() {
        var memo, oldClassName, rule, _i, _len, _ref3, _ref4;
        memo = this;
        oldClassName = null;
        while (oldClassName !== memo.className) {
          _ref4 = (_ref3 = rules[oldClassName = memo.className]) != null ? _ref3 : [];
          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
            rule = _ref4[_i];
            memo = rule.apply(memo, arguments);
            if (oldClassName !== memo.className) {
              break;
            }
          }
        }
        return memo;
      });
    };
  })();

  return Optimiser;

}).call(this);
